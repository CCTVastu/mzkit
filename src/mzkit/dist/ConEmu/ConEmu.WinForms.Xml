<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ConEmu.WinForms</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be appplied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ProvidesContextAttribute">
            <summary>
            Indicates the type member or parameter of some type, that should be used instead of all other ways
            to get the value that type. This annotation is useful when you have some "context" value evaluated
            and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example><code>
            class Foo {
              [ProvidesContext] IBarService _barService = ...;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by ReSharper code completion
            as a 'Source Template'. When extension method is completed over some expression, it's source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:JetBrains.Annotations.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:JetBrains.Annotations.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:JetBrains.Annotations.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:JetBrains.Annotations.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see> if the
            <see cref="T:JetBrains.Annotations.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="T:JetBrains.Annotations.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:JetBrains.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:JetBrains.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:JetBrains.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.NoReorder">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
        <member name="T:ConEmu.WinForms.AnsiLog">
            <summary>
            Manages reading the ANSI log output of the conemu and firing events with its data to the user.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.AnsiLog._fstream">
            <summary>
            When we found the ansi file.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.AnsiLog.Directory">
            <summary>
            The directory into which we instruct ConEmu to write its ansi log.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.AnsiLog.PumpStream">
            <summary>
            A function which processes the part of the stream which gets available (or does the rest of it at the end).
            </summary>
        </member>
        <member name="E:ConEmu.WinForms.AnsiLog.AnsiStreamChunkReceived">
            <summary>
                <para>Fires when the console process writes into its output or error stream. Gets a chunk of the raw ANSI stream contents.</para>
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.AnsiStreamChunkEventArgs">
            <summary>
            Holds the new chunk of the console ANSI stream.
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.AnsiStreamChunkEventArgs.Chunk">
            <summary>
            Gets the raw bytes of the chunk.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.AnsiStreamChunkEventArgs.GetMbcsText">
            <summary>
            Assuming the stream is encoded in the current system's MBCS encoding, gets its text.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.AnsiStreamChunkEventArgs.GetText(System.Text.Encoding)">
            <summary>
            Gets the text of the chunk assuming it's in the specific encoding.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuConstants.DefaultConsoleCommandLine">
            <summary>
            The default for <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine" />.
            Runs the stock ConEmu task for the Windows command line.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.ConEmuControl">
            <summary>
                <para>This is a console emulator control that embeds a fully functional console view in a Windows Forms window. It is capable of running any console application with full interactivity and advanced console functions. Applications will detect it as an actual console and will not fall back to the output redirection mode with reduced interactivity or formatting.</para>
                <para>The control can be used to run a console process in the console emulator. The console process is the single command executed in the control, which could be a simple executable (the console emulator is not usable after it exits), or an interactive shell like <c>cmd</c> or <c>powershell</c> or <c>bash</c>, which in turn can execute multiple commands, either by user input or programmatically with <see cref="M:ConEmu.WinForms.ConEmuSession.WriteInputText(System.String)" />. The console emulator is what implements the console and renders the console view in the control. A new console emulator (represented by a <see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession" />) is <see cref="M:ConEmu.WinForms.ConEmuControl.Start(ConEmu.WinForms.ConEmuStartInfo)">started</see> for each console process. After the root console process terminates, the console emulator might remain open (see <see cref="P:ConEmu.WinForms.ConEmuStartInfo.WhenConsoleProcessExits" />) and still present the console window, or get closed. After the console emulator exits, the control is blank until <see cref="M:ConEmu.WinForms.ConEmuControl.Start(ConEmu.WinForms.ConEmuStartInfo)" /> spawns a new console emulator for a console process in it. You cannot run more than one console emulator (or console process) simultaneousely.</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuControl._autostartinfo">
            <summary>
            Enabled by default, and with all default values (runs the cmd shell).
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuControl._nLastExitCode">
            <summary>
            After the first console process exits (not session), stores its exit code. Changes on the main thread only.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuControl._running">
            <summary>
            The running session, if currently running.
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuControl.AutoStartInfo">
            <summary>
                <para>Gets or sets whether this control will start the console process as soon as it's loaded on the form: yes if non-<c>NULL</c>, and no if <c>NULL</c>.</para>
                <para>Set this to <c>NULL</c> to prevent the console emulator from opening automatically. Adjust this object or assign a new one to setup the console process to be run in the console emulator automatically.</para>
                <para>You can either specify the console executable to run in <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine" />, or use its default value <see cref="F:ConEmu.WinForms.ConEmuConstants.DefaultConsoleCommandLine" /> for the default Windows console and execute your command in that console with <see cref="M:ConEmu.WinForms.ConEmuSession.WriteInputText(System.String)" /> (the console will remain operable and ready to run more commands after the command completes).</para>
            </summary>
            <remarks>
                <para>This object cannot be changed after the first <see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession">console emulator session</see> starts. The value of the property becomes <c>NULL</c> and cannot be changed either.</para>
                <para>If you're chaning <c>NULL</c> to non-<c>NULL</c> and the control has already been loaded, it will start executing a new session with these parameters immediately, so make sure you've completed settings up all the parameters before making the assignment.</para>
            </remarks>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuControl.IsStatusbarVisible">
            <summary>
            Gets or sets whether the status bar of the console emulator view should be visible.
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuControl.LastExitCode">
            <summary>
                <para>Gets the exit code of the most recently terminated console process.</para>
                <para><c>NULL</c> if no console process has exited in this control yet.</para>
                <para>Note that if a console process is currently running in the console emulator then you'd be getting the previous exit code until it exits.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuControl.RunningSession">
            <summary>
                <para>Gets the running console emulator session, or <c>NULL</c> if there currently is none.</para>
                <para>A session represents an open console emulator view displayed in the control, in which a console process is either still running, or has already terminated.</para>
                <para>To guarantee getting the running session object of a short-lived session before it closes, call <see cref="M:ConEmu.WinForms.ConEmuControl.Start(ConEmu.WinForms.ConEmuStartInfo)" /> manually rather than rely on <see cref="P:ConEmu.WinForms.ConEmuControl.AutoStartInfo" />.</para>
                <para>This only changes on the main thread.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuControl.State">
            <summary>
                <para>Gets the current state of the console emulator control regarding whether a console emulator is open in it, and whether there is still a console process running in that emulator.</para>
                <para>This only changes on the main thread.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuControl.IsConsoleEmulatorOpen">
            <summary>
                <para>Gets whether a console emulator is currently open, and its console window view is displayed in the control. Of <see cref="P:ConEmu.WinForms.ConEmuControl.State" />, that's either <see cref="F:ConEmu.WinForms.States.ConsoleEmulatorWithConsoleProcess" /> or <see cref="F:ConEmu.WinForms.States.ConsoleEmulatorEmpty" />.</para>
                <para>When a console emulator is not open, the control is blank.</para>
                <para>This only changes on the main thread.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuControl.Start(ConEmu.WinForms.ConEmuStartInfo)">
            <summary>
                <para>Starts a new console process in the console emulator control, and shows the console emulator view. When a session is not running, the control is blank.</para>
                <para>If another <see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession">session</see> is running, it will be closed, and the new session will replace it. <see cref="P:ConEmu.WinForms.ConEmuControl.AutoStartInfo" /> will call <see cref="M:ConEmu.WinForms.ConEmuControl.Start(ConEmu.WinForms.ConEmuStartInfo)" /> and create a session automatically if configured.</para>
            </summary>
            <remarks>
                <para>The control state transitions to <see cref="F:ConEmu.WinForms.States.ConsoleEmulatorWithConsoleProcess" />, then to <see cref="F:ConEmu.WinForms.States.ConsoleEmulatorEmpty" /> (unless configured to close on exit), then to <see cref="F:ConEmu.WinForms.States.Recycled" />.</para>
            </remarks>
            <returns>Returns the newly-started session, as in <see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession" />.</returns>
        </member>
        <member name="E:ConEmu.WinForms.ConEmuControl.StateChanged">
            <summary>
            Fires on the main thread whenever <see cref="P:ConEmu.WinForms.ConEmuControl.State" /> changes.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.ConEmuSession">
            <summary>
                <para>A single session of the console emulator running a console process. Each console process execution in the control spawns a new console emulator and a new session.</para>
                <para>When the console emulator starts, a console view appears in the control. The console process starts running in it immediately. When the console process terminates, the console emulator might or might not be closed, depending on the settings. After the console emulator closes, the control stops viewing the console, and this session ends.</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession.IsExecutingGuiMacrosInProcess">
            <summary>
            A service option. Whether to load the ConEmu helper DLL in-process to communicate with ConEmu (<c>True</c>, new mode), or start a new helper process to send each command (<c>False</c>, legacy mode).
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._ansilog">
            <summary>
            Non-NULL if we've requested ANSI log from ConEmu and are listening to it.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._dirTempWorkingFolder">
            <summary>
            Per-session temp files, like the startup options for ConEmu and ANSI log cache.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._guiMacroExecutor">
            <summary>
            Sends commands to the ConEmu instance and gets info from it.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._lifetime">
            <summary>
            Executed to process disposal.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._nConsoleProcessExitCode">
            <summary>
            The exit code of the console process, if it has already exited. <c>Null</c>, if the console process is still running within the console emulator.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._process">
            <summary>
            The ConEmu process, even after it exits.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._schedulerSta">
            <summary>
            Stores the main thread scheduler, so that all state properties were only changed on this thread.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._startinfo">
            <summary>
            The original parameters for this session; sealed, so they can't change after the session is run.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._taskConsoleEmulatorClosed">
            <summary>
            Task-based notification of the console emulator closing.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuSession._taskConsoleProcessExit">
            <summary>
            Task-based notification of the console process exiting.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.#ctor(ConEmu.WinForms.ConEmuStartInfo,ConEmu.WinForms.ConEmuSession.HostContext)">
            <summary>
            Starts the session.
            Opens the emulator view in the control (HWND given in <paramref name="hostcontext" />) by starting the ConEmu child process and giving it that HWND; ConEmu then starts the child Console Process for the commandline given in <paramref name="startinfo" /> and makes it run in the console emulator window.
            </summary>
            <param name="startinfo">User-defined startup parameters for the console process.</param>
            <param name="hostcontext">Control-related parameters.</param>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuSession.IsConsoleProcessExited">
            <summary>
                <para>Gets whether the console process has already exited (see <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited" />). The console emulator view might have closed as well, but might have not (see <see cref="P:ConEmu.WinForms.ConEmuStartInfo.WhenConsoleProcessExits" />).</para>
                <para>This state only changes on the main thread.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuSession.StartInfo">
            <summary>
                <para>Gets the start info with which this session has been started.</para>
                <para>All of the properties in this object are now readonly.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.BeginGuiMacro(System.String)">
            <summary>
            Starts construction of the ConEmu GUI Macro, see http://conemu.github.io/en/GuiMacro.html .
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.Close">
            <summary>
            An alias for <see cref="M:ConEmu.WinForms.ConEmuSession.CloseConsoleEmulator" />.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.CloseConsoleEmulator">
            <summary>
                <para>Closes the console emulator window, and kills the console process if it's still running.</para>
                <para>This also closes the running session, the control goes blank and ready for running a new session.</para>
                <para>To just kill the console process, use <see cref="M:ConEmu.WinForms.ConEmuSession.KillConsoleProcessAsync" />. If <see cref="P:ConEmu.WinForms.ConEmuStartInfo.WhenConsoleProcessExits" /> allows, the console emulator window might stay open after that.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.ExecuteGuiMacroTextAsync(System.String)">
            <summary>
                <para>Executes a ConEmu GUI Macro on the active console, see http://conemu.github.io/en/GuiMacro.html .</para>
                <para>This function takes for formatted text of a GUI Macro; to format parameters correctly, better use the <see cref="M:ConEmu.WinForms.ConEmuSession.BeginGuiMacro(System.String)" /> and the macro builder.</para>
            </summary>
            <param name="macrotext">The full macro command, see http://conemu.github.io/en/GuiMacro.html .</param>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.ExecuteGuiMacroTextSync(System.String)">
            <summary>
                <para>Executes a ConEmu GUI Macro on the active console, see http://conemu.github.io/en/GuiMacro.html , synchronously.</para>
                <para>This function takes for formatted text of a GUI Macro; to format parameters correctly, better use the <see cref="M:ConEmu.WinForms.ConEmuSession.BeginGuiMacro(System.String)" /> and the macro builder.</para>
            </summary>
            <param name="macrotext">The full macro command, see http://conemu.github.io/en/GuiMacro.html .</param>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.GetConsoleProcessExitCode">
            <summary>
                <para>Gets the exit code of the console process, if <see cref="P:ConEmu.WinForms.ConEmuSession.IsConsoleProcessExited">it has already exited</see>. Throws an exception if it has not.</para>
                <para>This state only changes on the main thread.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.KillConsoleProcessAsync">
            <summary>
                <para>Kills the console process running in the console emulator window, if it has not exited yet.</para>
                <para>This does not necessarily kill the console emulator process which displays the console window, but it might also close if <see cref="P:ConEmu.WinForms.ConEmuStartInfo.WhenConsoleProcessExits" /> says so.</para>
            </summary>
            <returns>Whether the process were killed (otherwise it has been terminated due to some other reason, e.g. exited on its own or killed by a third party).</returns>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.SendControlBreakAsync">
            <summary>
                <para>Sends the <c>Control+Break</c> signal to the console process, which will most likely abort it.</para>
                <para>Unlike <see cref="M:ConEmu.WinForms.ConEmuSession.KillConsoleProcessAsync" />, this is a soft signal which might be processed by the console process for a graceful shutdown, or ignored altogether.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.SendControlCAsync">
            <summary>
                <para>Sends the <c>Control+C</c> signal to the payload console process, which will most likely abort it.</para>
                <para>Unlike <see cref="M:ConEmu.WinForms.ConEmuSession.KillConsoleProcessAsync" />, this is a soft signal which might be processed by the console process for a graceful shutdown, or ignored altogether.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.WaitForConsoleEmulatorCloseAsync">
            <summary>
                <para>Waits until the console emulator closes and the console emulator view gets hidden from the control, or completes immediately if it has already exited.</para>
                <para>Note that the console process might have terminated long before this moment without closing the console emulator unless <see cref="F:ConEmu.WinForms.WhenConsoleProcessExits.CloseConsoleEmulator" /> were selected in the startup options.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.WaitForConsoleProcessExitAsync">
            <summary>
                <para>Waits for the console process running in the console emulator to terminate, or completes immediately if it has already terminated.</para>
                <para>If not <see cref="F:ConEmu.WinForms.WhenConsoleProcessExits.CloseConsoleEmulator" />, the console emulator stays, otherwise it closes also, and the console emulator window is hidden from the control.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.WriteInputText(System.String)">
            <summary>
                <para>Writes text to the console input, as if it's been typed by user on the keyboard.</para>
                <para>Whether this will be visible (=echoed) on screen is up to the running console process.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.WriteOutputText(System.String)">
            <summary>
                <para>Writes text to the console output, as if the current running console process has written it to stdout.</para>
                <para>Use with caution, as this might interfere with console process output in an unpredictable manner.</para>
            </summary>
        </member>
        <member name="E:ConEmu.WinForms.ConEmuSession.AnsiStreamChunkReceived">
            <summary>
                <para>Fires on the main thread when the console process writes into its output or error streams. Gets a chunk of the raw ANSI stream contents.</para>
                <para>For processes which write immediately on startup, this event might fire some chunks before you can start sinking it. To get notified reliably, use <see cref="P:ConEmu.WinForms.ConEmuStartInfo.AnsiStreamChunkReceivedEventSink" />.</para>
                <para>To enable sinking this event, you must have <see cref="P:ConEmu.WinForms.ConEmuStartInfo.IsReadingAnsiStream" /> set to <c>True</c> before starting the console process.</para>
                <para>If you're reading the ANSI log with <see cref="E:ConEmu.WinForms.ConEmuSession.AnsiStreamChunkReceived" />, it's guaranteed that all the events for the log will be fired before <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited" />, and there will be no events afterwards.</para>
            </summary>
        </member>
        <member name="E:ConEmu.WinForms.ConEmuSession.ConsoleEmulatorClosed">
            <summary>
                <para>Fires on the main thread when the console emulator closes and the console emulator window is hidden from the control.</para>
                <para>Note that the console process might have terminated long before this moment without closing the console emulator unless <see cref="F:ConEmu.WinForms.WhenConsoleProcessExits.CloseConsoleEmulator" /> were selected in the startup options.</para>
                <para>For short-lived processes, this event might fire before you can start sinking it. To get notified reliably, use <see cref="M:ConEmu.WinForms.ConEmuSession.WaitForConsoleEmulatorCloseAsync" /> or <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleEmulatorClosedEventSink" />.</para>
            </summary>
        </member>
        <member name="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited">
            <summary>
                <para>Fires on the main thread when the console process running in the console emulator terminates.</para>
                <para>If not <see cref="F:ConEmu.WinForms.WhenConsoleProcessExits.CloseConsoleEmulator" />, the console emulator stays, otherwise it closes also, and the console emulator window is hidden from the control.</para>
                <para>For short-lived processes, this event might fire before you can start sinking it. To get notified reliably, use <see cref="M:ConEmu.WinForms.ConEmuSession.WaitForConsoleProcessExitAsync" /> or <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessExitedEventSink" />.</para>
                <para>If you're reading the ANSI log with <see cref="E:ConEmu.WinForms.ConEmuSession.AnsiStreamChunkReceived" />, it's guaranteed that all the events for the log will be fired before <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited" />, and there will be no events afterwards.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.Init_ConsoleProcessMonitoring">
            <summary>
            Watches for the status of the payload console process to fetch its exitcode when done and notify user of that.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.Init_MakeConEmuCommandLine_EmitConfigFile_EscapeEchoText(System.String)">
            <summary>
            Applies escaping so that (1) it went as a single argument into the ConEmu's <c>NextArg</c> function; (2) its special chars were escaped according to the ConEmu's <c>DoOutput</c> function which implements this echo.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.Init_PayloadProcessMonitoring_WaitForExitCodeAsync">
            <summary>
            Async-loop retries for getting the root payload process to await its exit.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuSession.TryFireConsoleProcessExited(System.Int32)">
            <summary>
            Fires the payload exited event if it has not been fired yet.
            </summary>
            <param name="nConsoleProcessExitCode"></param>
        </member>
        <member name="T:ConEmu.WinForms.ConEmuSession.HostContext">
            <summary>
            Covers parameters of the host control needed to run the session. <see cref="T:ConEmu.WinForms.ConEmuStartInfo" /> tells what to run and how, while this class tells “where” and is not directly user-configurable, it's derived from the hosting control.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.ConEmuStartInfo">
            <summary>
            Describes the parameters for running the console process in the console emulator, including the command line to run.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.ConEmuStartInfo.LogLevels">
            <summary>
            LogLevels: Empty, NotStarted, Running, Exited.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuStartInfo.LogLevels.Disabled">
            <summary>
            Logging is disabled.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuStartInfo.LogLevels.Basic">
            <summary>
            Initial logging level, recommended. Implies switch "-Log".
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuStartInfo.LogLevels.Detailed">
            <summary>
            More data would be logging. Implies switch "-Log2".
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuStartInfo.LogLevels.Advanced">
            <summary>
            Almost Full logging level. Implies switch "-Log3".
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.ConEmuStartInfo.LogLevels.Full">
            <summary>
            Maximum logging level. Implies switch "-Log4".
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuStartInfo.#ctor">
            <summary>
                <para>Creates a new object with all the parameters in their default values.</para>
                <para>The console emulator will run the default <c>CMD</c> shell with such an empty object.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuStartInfo.#ctor(System.String)">
            <summary>
            Creates a new object and defines the command line for the console process to be run in the console emulator, <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine" />.
            </summary>
            <param name="sConsoleProcessCommandLine">Value for <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine" />.</param>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.AnsiStreamChunkReceivedEventSink">
            <summary>
                <para>Gets or sets an event sink for the <see cref="E:ConEmu.WinForms.ConEmuSession.AnsiStreamChunkReceived" /> event even before the console process starts, which guarantees that your event sink won't miss the early data written by the console process on its very startup.</para>
                <para>Settings this to a non-<c>NULL</c> value also implies on <see cref="P:ConEmu.WinForms.ConEmuStartInfo.IsReadingAnsiStream" />.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.BaseConfiguration">
            <summary>
                <para>The base XML configuration for the ConEmu console emulator, in the standard ConEmu settings files XML format.</para>
                <para>The initial value of the property returns the configuration file which is used by default in the console emulator control. You can change this very document instance, and it will not affect other sessions.</para>
                <para>The final XML settings file which will be supplied to the ConEmu console emulator takes this document as a baseline and applies other relevant properties from this object (as well as host configuration options from the control) on top of it. These changes are applied to a copy, this original document remains unchanged and can be reused.</para>
                <para>This property cannot be changed when the process is running.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.ConEmuConsoleExtenderExecutablePath">
            <summary>
                <para>Advanced configuration.</para>
                <para>Gets or sets the path to the ConEmu console extender (<c>ConEmuC.exe</c>).</para>
                <para>Normally, will be autodetected from the path to this DLL or from <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConEmuExecutablePath" />.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.ConEmuConsoleServerExecutablePath">
            <summary>
                <para>Advanced configuration.</para>
                <para>Gets or sets the path to the ConEmu console server (<c>ConEmuCD.dll</c>). MUST match the processor architecture of the current process.</para>
                <para>Normally, will be autodetected from the path to this DLL or from <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConEmuExecutablePath" />.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.ConEmuExecutablePath">
            <summary>
                <para>Advanced configuration.</para>
                <para>Gets or sets the path to the <c>ConEmu.exe</c> which will be the console emulator root process.</para>
                <para>Normally, will be autodetected from the path to this DLL.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleEmulatorClosedEventSink">
            <summary>
                <para>Gets or sets an event sink for <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleEmulatorClosed" /> even before the console process starts, which guarantees that your event sink won't miss events even for short-lived processes.</para>
                <para>Alternatively, use <see cref="M:ConEmu.WinForms.ConEmuSession.WaitForConsoleEmulatorCloseAsync" /> for reliable notification.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine">
            <summary>
                <para>The command line to execute in the console emulator as the top-level console process. Each console emulator session can run only one console command.</para>
                <para>The default is <see cref="F:ConEmu.WinForms.ConEmuConstants.DefaultConsoleCommandLine" />, which opens an interactive <c>CMD</c> shell in the console emulator.</para>
                <para>This property cannot be changed when the process is running.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessExitedEventSink">
            <summary>
                <para>Gets or sets an event sink for <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited" /> even before the console process starts, which guarantees that your event sink won't miss events even for short-lived processes.</para>
                <para>Alternatively, use <see cref="M:ConEmu.WinForms.ConEmuSession.WaitForConsoleProcessExitAsync" /> for reliable notification.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.GreetingText">
            <summary>
                <para>Gets or sets the custom greeting text which will be echoed into the console emulator stdout before the <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine" /> starts executing.</para>
                <para>Note that to echo the <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine" /> itself you can use the more specific <see cref="P:ConEmu.WinForms.ConEmuStartInfo.IsEchoingConsoleCommandLine" /> option (which prints after the custom greeting text).</para>
                <para>Newline handling: a newline is added automatically at the end, if missing; if there's a single newline at the end, it is retained AS IS. If you want an empty line after text, add a double newline.</para>
                <para>The default is an empty string for no custom greeting.</para>
                <para>This property cannot be changed when the process is running.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.IsEchoingConsoleCommandLine">
            <summary>
                <para>Gets or sets whether the <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine">console command line</see> will be echoed into the console emulator stdout before being executed. If there's also <see cref="P:ConEmu.WinForms.ConEmuStartInfo.GreetingText" />, it goes first.</para>
                <para>The default is <c>False</c>.</para>
                <para>This property cannot be changed when the process is running.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.IsElevated">
            <summary>
                <para>Gets or sets whether the console process is to be run elevated (an elevation prompt will be shown as needed).</para>
                <para>The default is <c>False</c>.</para>
                <para>This property cannot be changed when the process is running.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.LogLevel">
            <summary>
                <para>Gets or sets whether the ConEmu will write some diagnostics into <see href="https://conemu.github.io/en/LogFiles.html">LogFiles</see>.</para>
                <para>LogFiles are created in ConEmu program folder if it's write-enabled, otherwise they would be placed in Desktop folder <c>ConEmuLogs</c>.</para>
                <para>The default is <c>Disabled</c>.</para>
                <para>This property cannot be changed when the process is running.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.IsReadingAnsiStream">
            <summary>
                <para>Gets or sets whether the console emulator will be reading the raw ANSI stream of the console and firing the <see cref="E:ConEmu.WinForms.ConEmuSession.AnsiStreamChunkReceived" /> events (and notifying <see cref="P:ConEmu.WinForms.ConEmuStartInfo.AnsiStreamChunkReceivedEventSink" />).</para>
                <para>This can only be decided on before the console process starts.</para>
                <para>Setting <see cref="P:ConEmu.WinForms.ConEmuStartInfo.AnsiStreamChunkReceivedEventSink" /> to a non-<c>NULL</c> value implies on a <c>True</c> value for this property.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.StartupDirectory">
            <summary>
            Optional. Overrides the startup directory for the console process.
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConEmuStartInfo.WhenConsoleProcessExits">
            <summary>
                <para>Gets or sets whether the console emulator view should remain open and keep displaying the last console contents after the console process specified in <see cref="P:ConEmu.WinForms.ConEmuStartInfo.ConsoleProcessCommandLine" /> terminates.</para>
                <para>See comments on enum members for details on specific behavior.</para>
                <para>The default is <see cref="F:ConEmu.WinForms.WhenConsoleProcessExits.KeepConsoleEmulatorAndShowMessage" />.</para>
                <para>This property cannot be changed when the process is running.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuStartInfo.EnumEnv">
            <summary>
            Gets the startup environment variables. This does not reflect the env vars of a running console process.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuStartInfo.GetEnv(System.String)">
            <summary>
            Gets the startup environment variable. This does not reflect the env vars of a running console process.
            </summary>
            <param name="name">Environment variable name, case-insensitive.</param>
            <returns>Environment variable value.</returns>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuStartInfo.SetEnv(System.String,System.String)">
            <summary>
                <para>Sets the startup environment variable for the console process, before it is started.</para>
                <para>This cannot be used to change the environment variables of a running console process.</para>
            </summary>
            <param name="name">Environment variable name, case-insensitive.</param>
            <param name="value">Environment variable value, or <c>NULL</c> to remove this environment variable.</param>
        </member>
        <member name="M:ConEmu.WinForms.ConEmuStartInfo.MarkAsUsedUp">
            <summary>
            Marks this instance as used-up and prevens further modifications.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.GetInfoRoot">
            <summary>
            Handles the <c>GetInfo</c> GuiMacro for the <c>Root</c> command.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.ExitCode">
            <summary>
            Exit code of the payload process, if it has exited.
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.GetInfoRoot.IsRunning">
            <summary>
            Whether the payload process were running at the moment when the macro were executed.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.Name">
            <summary>
            Name of the process, should always be available whether it's running or not (yet/already).
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.Pid">
            <summary>
            The process ID, available only when the payload process is running.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.State">
            <summary>
            The current state of the root console process, as in the <c>GetInfo Root</c> GUI Macro <c>State</c> field: Empty, NotStarted, Running, Exited.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.GetInfoRoot.States">
            <summary>
            State: Empty, NotStarted, Running, Exited.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.States.Empty">
            <summary>
            If there are not consoles in ConEmu.
            </summary>
            <example><code>&lt;Root State="Empty" /&gt;</code></example>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.States.NotStarted">
            <summary>
            If console initialization is in progress (<c>ping localhost -t</c> for example).
            </summary>
            <example><code>&lt;Root State="NotStarted" Name="ping.exe" /&gt;</code></example>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.States.Running">
            <summary>
            If root process was started and is running. Note, <c>259</c> in <c>ExitCode</c> is <c>STILL_ACTIVE</c> constant.
            </summary>
            <example><code>&lt;Root State="Running" Name="ping.exe" PID="7136" ExitCode="259" UpTime="3183" /&gt;</code></example>
        </member>
        <member name="F:ConEmu.WinForms.GetInfoRoot.States.Exited">
            <summary>
                <para>• If root process was finished (terminated by `Ctrl+C` as example).</para>
                <para>• Another example for `cmd.exe` normal exit.</para>
            </summary>
            <example><code>&lt;Root State="Exited" Name="ping.exe" PID="7136" ExitCode="3221225786" UpTime="10195" /&gt;</code></example>
            <example><code>&lt;Root State="Exited" Name="cmd.exe" PID="6688" ExitCode="0" UpTime="1825" /&gt;</code></example>
        </member>
        <member name="T:ConEmu.WinForms.GuiMacroExecutor">
            <summary>
                <para>Implements calling GuiMacro to the remote ConEmu instance, and getting the result.</para>
                <para>Got switching implementation for out-of-process (classic, via a console tool) and in-process (new feature which loads the helper comm DLL directly) access.</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GuiMacroExecutor._lock">
            <summary>
            Prevent unloads when async calls are being placed.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.GuiMacroExecutor.#ctor(System.String)">
            <summary>
            Inits the object, loads the extender DLL if known. If <c>NULL</c>, in-process operations will not be available.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.GuiMacroExecutor.ExecuteInProcessAsync(System.Int32,System.String)">
            <summary>
                <para>Loads the ConEmu Console Server DLL and uses it to execute the GUI Macro.</para>
                <para>The execution is async, because the call must not be placed on the same thread.</para>
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.GuiMacroExecutor.ExecuteViaExtenderProcessAsync(System.String,System.Int32,System.String)">
            <summary>
            Invokes <c>ConEmuC.exe</c> to execute the GUI Macro.
            The execution is asynchronous.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.GuiMacroExecutor.FGuiMacro">
            <summary>
                <code>int __stdcall GuiMacro(LPCWSTR asInstance, LPCWSTR asMacro, BSTR* bsResult = NULL);</code>
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.GuiMacroBuilder">
            <summary>
            Fluent API for constructing a GUI macro. Start with the running <see cref="T:ConEmu.WinForms.ConEmuSession" />, call <see cref="M:ConEmu.WinForms.ConEmuSession.BeginGuiMacro(System.String)" />.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.GuiMacroBuilder.ExecuteAsync">
            <summary>
            Renders the macro and executes with ConEmu, asynchronously.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.GuiMacroBuilder.ExecuteSync">
            <summary>
            Renders the macro and executes with ConEmu, getting the result synchronously.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.GuiMacroBuilder.WithParam(System.String)">
            <summary>
            Adds a parameter.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.GuiMacroBuilder.WithParam(System.Int32)">
            <summary>
            Adds a parameter.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.GuiMacroResult">
            <summary>
            A result of executing the GUI macro.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GuiMacroResult.IsSuccessful">
            <summary>
            Whether macro execution returned success.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.GuiMacroResult.Response">
            <summary>
            String response of the command, “<c>OK</c>” if successful and without output.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.ConsoleProcessExitedEventArgs">
            <summary>
            Gives the exit code of the console process when it exits in the console emulator.
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.ConsoleProcessExitedEventArgs.ExitCode">
            <summary>
            Gets the exit code of the console process.
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.Resources.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.Resources.ConEmuSettingsTemplate">
            <summary>
              查找 System.Byte[] 类型的本地化资源。
            </summary>
        </member>
        <member name="T:ConEmu.WinForms.States">
            <summary>
            <see cref="T:ConEmu.WinForms.ConEmuControl" /> states.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.States.Unused">
            <summary>
                <para>There has been no console emulator opened in this control yet.</para>
                <para>The control is now empty, and <see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession" /> is <c>NULL</c>. A new session can be started with <see cref="M:ConEmu.WinForms.ConEmuControl.Start(ConEmu.WinForms.ConEmuStartInfo)" />.</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.States.ConsoleEmulatorWithConsoleProcess">
            <summary>
                <para>The console emulator is open, and the console process is running in it.</para>
                <para><see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession" /> is available. A new session cannot be started until the current session is closed (<see cref="M:ConEmu.WinForms.ConEmuSession.CloseConsoleEmulator" />).</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.States.ConsoleEmulatorEmpty">
            <summary>
                <para>The console emulator is still open, but the console process in it has already exited, even though the console view is still visible in the control.</para>
                <para>The console emulator stays open in this case if <see cref="P:ConEmu.WinForms.ConEmuStartInfo.WhenConsoleProcessExits" /> allows it.</para>
                <para><see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession" /> is available. A new session cannot be started until the current session is closed (<see cref="M:ConEmu.WinForms.ConEmuSession.CloseConsoleEmulator" />).</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.States.Recycled">
            <summary>
                <para>There were a console emulator in this control, but its console process has exited, and then the terminal were closed.</para>
                <para>The control is now empty and not showing the console view, and <see cref="P:ConEmu.WinForms.ConEmuControl.RunningSession" /> is <c>NULL</c>. A new session can be started with <see cref="M:ConEmu.WinForms.ConEmuControl.Start(ConEmu.WinForms.ConEmuStartInfo)" />.</para>
            </summary>
        </member>
        <member name="P:ConEmu.WinForms.Util.TaskHelpers.CompletedTask">
            <summary>Gets a task that's already been completed successfully.</summary>
        </member>
        <member name="M:ConEmu.WinForms.Util.TaskHelpers.Delay(System.TimeSpan)">
            <summary>
            Creates a started tasks which will get a completed state after the specified amount of time.
            </summary>
        </member>
        <member name="M:ConEmu.WinForms.Util.TaskHelpers.FromResult``1(``0)">
            <summary>Gets a task that's already been completed successfully.</summary>
        </member>
        <member name="M:ConEmu.WinForms.Util.WinApi.EnumChildWindows(System.Void*,System.Void*,System.IntPtr)">
            <summary>
            The EnumChildWindows function enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function. EnumChildWindows continues until the last child window is enumerated or the callback function returns FALSE.
            </summary>
            <param name="hWndParent">[in] Handle to the parent window whose child windows are to be enumerated. If this parameter is NULL, this function is equivalent to EnumWindows. Windows 95/98/Me: hWndParent cannot be NULL.</param>
            <param name="lpEnumFunc">[in] Pointer to an application-defined callback function. For more information, see EnumChildProc.</param>
            <param name="lParam">[in] Specifies an application-defined value to be passed to the callback function.</param>
            <returns>Not used.</returns>
            <remarks>If a child window has created child windows of its own, EnumChildWindows enumerates those windows as well. A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The function does not enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process. </remarks>
        </member>
        <member name="M:ConEmu.WinForms.Util.WinApi.MoveWindow(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The MoveWindow function changes the position and dimensions of the specified window. For a top-level window, the position and dimensions are relative to the upper-left corner of the screen. For a child window, they are relative to the upper-left corner of the parent window's client area.
            </summary>
            <param name="hWnd">[in] Handle to the window. </param>
            <param name="X">[in] Specifies the new position of the left side of the window. </param>
            <param name="Y">[in] Specifies the new position of the top of the window. </param>
            <param name="nWidth">[in] Specifies the new width of the window. </param>
            <param name="nHeight">[in] Specifies the new height of the window. </param>
            <param name="bRepaint">[in] Specifies whether the window is to be repainted. If this parameter is TRUE, the window receives a message. If the parameter is FALSE, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ConEmu.WinForms.Util.WinApi.OpenProcess(System.UInt32,System.Int32,System.UInt32)">
            <summary>Opens an existing local process object.</summary>
            <param name="dwDesiredAccess">The access to the process object.</param>
            <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle.</param>
            <param name="dwProcessId">The identifier of the local process to be opened. If the specified process is the System Process (0x00000000), the function fails and the last error code is ERROR_INVALID_PARAMETER. If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access restrictions prevent user-level code from opening them.</param>
            <returns>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ConEmu.WinForms.Util.WinApi.SetFocus(System.Void*)">
            <summary>
            The SetFocus function sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue. The SetFocus function sends a WM_KILLFOCUS message to the window that loses the keyboard focus and a WM_SETFOCUS message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. If a window is active but does not have the focus, any key pressed will produce the WM_SYSCHAR, WM_SYSKEYDOWN, or WM_SYSKEYUP message. If the VK_MENU key is also pressed, the lParam parameter of the message will have bit 30 set. Otherwise, the messages produced do not have this bit set. By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread's message queue.
            </summary>
            <param name="hWnd">[in] Handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored. </param>
            <returns>If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the hWnd parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="T:ConEmu.WinForms.Util.WinApi.EnumWindowsProc">
            <summary>
            The EnumWindowsProc function is an application-defined callback function used with the EnumWindows or EnumDesktopWindows function. It receives top-level window handles. The WNDENUMPROC type defines a pointer to this callback function. EnumWindowsProc is a placeholder for the application-defined function name.
            </summary>
            <param name="hwnd">[in] Handle to a top-level window. </param>
            <param name="lParam">[in] Specifies the application-defined value given in EnumWindows or EnumDesktopWindows. </param>
            <returns>To continue enumeration, the callback function must return TRUE; to stop enumeration, it must return FALSE.</returns>
            <remarks>An application must register this callback function by passing its address to EnumWindows or EnumDesktopWindows. </remarks>
        </member>
        <member name="T:ConEmu.WinForms.WhenConsoleProcessExits">
            <summary>
            Controls behavior of the console emulator when the console process running in it terminates.
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.WhenConsoleProcessExits.CloseConsoleEmulator">
            <summary>
                <para>When the console process exits, the console emulator is closed, and its window is hidden from the control.</para>
                <para>The control shows blank space, output text disappears.</para>
                <para><see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited" /> and <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleEmulatorClosed" /> are both fired at this moment.</para>
                <para>The <see cref="T:ConEmu.WinForms.ConEmuControl">console emulator control</see> is ready for running a new <see cref="T:ConEmu.WinForms.ConEmuSession">session</see>.</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.WhenConsoleProcessExits.KeepConsoleEmulator">
            <summary>
                <para>When the console process exits, the console emulator stays open, and its window remains visible in the control, with all the console output text.</para>
                <para>No additional message is written to the console output, but you can still use <see cref="M:ConEmu.WinForms.ConEmuSession.WriteOutputText(System.String)" /> to write any text.</para>
                <para>Pressing ESC or ENTER closes the console emulator, makes the control blank, and allows to run further <see cref="T:ConEmu.WinForms.ConEmuSession">console emulator sessions</see> in this control.</para>
                <para><see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited" /> fires immediately, and <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleEmulatorClosed" /> fires on user's ESC/ENTER, or when the console emulator is closed programmatically.</para>
            </summary>
        </member>
        <member name="F:ConEmu.WinForms.WhenConsoleProcessExits.KeepConsoleEmulatorAndShowMessage">
            <summary>
                <para>When the console process exits, the console emulator stays open, and its window remains visible in the control, with all the console output text.</para>
                <para>The message <c>“Press Enter or Esc to close console...”</c> is displayed.</para>
                <para>Pressing ESC or ENTER closes the console emulator, makes the control blank, and allows to run further <see cref="T:ConEmu.WinForms.ConEmuSession">console emulator sessions</see> in this control.</para>
                <para><see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleProcessExited" /> fires immediately, and <see cref="E:ConEmu.WinForms.ConEmuSession.ConsoleEmulatorClosed" /> fires on user's ESC/ENTER, or when the console emulator is closed programmatically.</para>
            </summary>
        </member>
        <member name="T:Microsoft.Build.Utilities.CommandLineBuilder">
            <summary>
            (1) Make sure values containing hyphens are quoted (RC at least requires this)
            (2) Escape any embedded quotes. 
                -- Literal double quotes should be written in the form \" not ""
                -- Backslashes falling just before doublequotes must be doubled.
                -- Literal double quotes can only occur in pairs (you cannot pass a single literal double quote)
            	-- Functional double quotes (for example to handle spaces) are best put around both name and value
            	    in switches like /Dname=value.
            </summary> 
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.#ctor(System.Boolean)">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.Length">
            <summary>
            Returns the length of the current command
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.CommandLine">
            <summary>
            Retrieves the private StringBuilder instance for inheriting classes
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.ToString">
            <summary>
            Return the command-line as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Build.Utilities.CommandLineBuilder._quoteHyphens">
            <summary>
             Should hyphens be quoted or not
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.CommandLineBuilder._allowedUnquoted">
            <summary>
            Instead of defining which characters must be quoted, define 
            which characters we know its safe to not quote. This way leads
            to more false-positives (which still work, but don't look as 
            nice coming out of the logger), but is less likely to leave a 
            security hole.
            </summary>
        </member>
        <member name="F:Microsoft.Build.Utilities.CommandLineBuilder._definitelyNeedQuotes">
            <summary>
            Also, define the characters that we know for certain need quotes.
            This is partly to document which characters we know can cause trouble
            and partly as a sanity check against a bug creeping in.
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.DefinitelyNeedQuotes">
            <summary>
            Use a private property so that we can lazy initialize the regex
            </summary>
        </member>
        <member name="P:Microsoft.Build.Utilities.CommandLineBuilder.AllowedUnquoted">
            <summary>
            Use a private getter property to we can lazy initialize the regex
            </summary>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(System.String)">
            <summary>
            Checks the given switch parameter to see if it must/can be quoted.
            </summary>
            <param name="parameter">the string to examine for characters that require quoting</param>
            <returns>true, if parameter should be quoted</returns>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty">
            <summary>
            Add a space to the specified string if and only if it's not empty. 
            </summary>
            <remarks>
            This is a pretty obscure method and so it's only available to inherited classes.
            </remarks>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(System.String)">
            <summary>
            Appends a string. Quotes are added if they are needed.
            This method does not append a space to the command line before executing.
            </summary>
            <remarks>
            Escapes any double quotes in the string.
            </remarks>
            <param name="textToAppend">The string to append</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder,System.String)">
            <summary>
            Appends given text to the buffer after first quoting the text if necessary.
            </summary>
            <param name="buffer"></param>
            <param name="unquotedTextToAppend"></param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(System.String)">
            <summary>
            Appends a string. No quotes are added.
            This method does not append a space to the command line before executing.
            </summary>
            <example>
            AppendTextUnquoted(@"Folder name\filename.cs") => "Folder name\\filename.cs"
            </example>
            <remarks>
            In the future, this function may fixup 'textToAppend' to handle
            literal embedded quotes.
            </remarks>
            <param name="textToAppend">The string to append</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(System.String)">
            <summary>
            Appends a file name. Quotes are added if they are needed. 
            If the first character of the file name is a dash, ".\" is prepended to avoid confusing the file name with a switch
            This method does not append a space to the command line before executing.
            </summary>
            <example>
            AppendFileNameWithQuoting("-StrangeFileName.cs") => ".\-StrangeFileName.cs"
            </example>
            <remarks>
            In the future, this function may fixup 'text' to handle
            literal embedded quotes.
            </remarks>
            <param name="fileName">The file name to append</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(System.String)">
            <summary>
            Appends a file name quoting it if necessary.
            This method appends a space to the command line (if it's not currently empty) before the file name.
            </summary>
            <example>
            AppendFileNameIfNotNull("-StrangeFileName.cs") => ".\-StrangeFileName.cs"
            </example>
            <param name="fileName">File name to append, if it's null this method has no effect</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(System.String[],System.String)">
            <summary>
            Appends array of file name strings, quoting them if necessary, delimited by a delimiter.
            This method appends a space to the command line (if it's not currently empty) before the file names.
            </summary>
            <example>
            AppendFileNamesIfNotNull(new string[] {"Alpha.cs", "Beta.cs"}, ",") => "Alpha.cs,Beta.cs"
            </example>
            <param name="fileNames">File names to append, if it's null this method has no effect</param>
            <param name="delimiter">The delimiter between file names</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(System.String)">
            <summary>
            Appends a command-line switch that has no separate value, without any quoting.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitch("/utf8output") => "/utf8output"
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(System.String,System.String)">
            <summary>
            Appends a command-line switch that takes a single string parameter, quoting the parameter if necessary.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchIfNotNull("/source:", "File Name.cs") => "/source:\"File Name.cs\""
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameter">Switch parameter to append, quoted if necessary. If null, this method has no effect.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(System.String,System.String)">
            <summary>
            Throws if the parameter has a double-quote in it. This is used to prevent parameter
            injection. It's virtual so that tools can override this method if they want to have quotes escaped in filenames
            </summary>
            <param name="switchName">Switch name for error message</param>
            <param name="parameter">Switch parameter to scan</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(System.String,System.String[],System.String)">
            <summary>
            Appends a command-line switch that takes a string[] parameter,
            and add double-quotes around the individual filenames if necessary.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchIfNotNull("/sources:", new string[] {"Alpha.cs", "Be ta.cs"}, ";") => "/sources:Alpha.cs;\"Be ta.cs\""
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameters">Switch parameters to append, quoted if necessary. If null, this method has no effect.</param>
            <param name="delimiter">Delimiter to put between individual parameters, may not be null (may be empty)</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(System.String,System.String)">
            <summary>
            Appends the literal parameter without trying to quote.
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchUnquotedIfNotNull("/source:", "File Name.cs") => "/source:File Name.cs"
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameter">Switch parameter to append, not quoted. If null, this method has no effect.</param>
        </member>
        <member name="M:Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(System.String,System.String[],System.String)">
            <summary>
            Appends a command-line switch that takes a string[] parameter, not quoting the individual parameters
            This method appends a space to the command line (if it's not currently empty) before the switch.
            </summary>
            <example>
            AppendSwitchUnquotedIfNotNull("/sources:", new string[] {"Alpha.cs", "Be ta.cs"}, ";") => "/sources:Alpha.cs;Be ta.cs"
            </example>
            <param name="switchName">The switch to append to the command line, may not be null</param>
            <param name="parameters">Switch parameters to append, not quoted. If null, this method has no effect.</param>
            <param name="delimiter">Delimiter to put between individual parameters, may not be null (may be empty)</param>
        </member>
    </members>
</doc>
